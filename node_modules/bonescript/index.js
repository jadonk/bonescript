// Copyright (C) 2011 - Texas Instruments, Jason Kridner 
//
// 
var fs = require('fs');
var child_process = require('child_process');
var http = require('http');
var url = require('url');
var path = require('path');
var cluster = require('cluster');
var eeprom = require('./eeprom');
var parse = require('./parse');
var platform = require('./bone').bone;

var f = {};

var myeval = function(x) {
    console.log('eval("' + x + '");');
    var y;
    try {
        y = eval(x);
    } catch(ex) {
        y = undefined;
        console.log('myeval error: ' + ex);
        throw('myeval error: ' + ex);
    }
    console.log('result = ' + y);
    return(y);
};

var myrequire = function(packageName, onfail) {
    var y = {};
    try {
        y = require(packageName);
        y.exists = true;
    } catch(ex) {
        y.exists = false;
        console.log("Optional package '" + packageName + "' not loaded");
        if(onfail) onfail();
    }
    return(y);
};

var socketio = myrequire('socket.io', function() {
    console.log("Dynamic web features not enabled");
});
myrequire('systemd', function() {
    console.log("Startup as socket-activated service under systemd not enabled");
});

var misc = myrequire('./build/Release/misc');

var gOUTPUT = "out";
var gINPUT = "in";
var gINPUT_PULLUP = "in_pullup";
var gHIGH = 1;
var gLOW = 0;
var gLSBFIRST = 1;  // used in: shiftOut(dataPin, clockPin, bitOrder, val)
var gMSBFIRST = 0;
var gCHANGE = "both";
var gRISING = "rising";
var gFALLING = "falling";

// Keep track of allocated resources
var gpio = [];
var pwm = [];

// returned object has:
//  mux: index of mux mode
//  options: array of mode names
//  slew: 'fast' or 'slow'
//  rx: 'enabled' or 'disabled'
//  pullup: 'diabled', 'pullup' or 'pulldown'
//  pin: key string for pin
//  name: pin name
f.getPinMode = function(pin, callback) {
    //console.log('getPinMode(' + pin.key + '): ' + muxFile);
    var mode = {'pin': pin.key, 'name': pin.name};
    if(pin.options) mode.options = pin.options;
    var muxFile = '/sys/kernel/debug/omap_mux/' + pin.mux;
    var pinctrlFile = '/sys/kernel/debug/pinctrl/44e10800.pinmux/pins';
    var muxRegOffset = parseInt(pin.muxRegOffset, 16);
    var readOmapMux = function(err, data) {
        if(err) console.log('readOmapMux error: ' + err);
        mode = parse.modeFromOmapMux(data, mode);
        callback(mode);
    };
    var readPinctrl = function(err, data) {
        if(err) console.log('readPinctrl error: ' + err);
        mode = parse.modeFromPinctrl(data, muxRegOffset, 0x44e10800, mode);
        callback(mode);
    };
    var tryPinctrl = function(exists) {
        if(exists) {
            fs.readFile(pinctrlFile, 'utf8', readPinctrl);
        } else {
            console.log('getPinMode(' + pin.key + '): no valid mux data');
            callback(mode);
        }
    };
    var tryOmapMux = function(exists) {
        if(exists) {
            fs.readFile(muxFile, 'utf8', readOmapMux);
        } else {
            path.exists(pinctrlFile, tryPinctrl);
        }
    };
    if(callback) {
        path.exists(muxFile, tryOmapMux);
    } else {
        try {
            var data = fs.readFileSync(muxFile, 'utf8');
            mode = parse.modeFromOmapMux(data, mode);
        } catch(ex) {
            try {
                var data2 = fs.readFileSync(pinctrlFile, 'utf8');
                mode = parse.modeFromPinctrl(data2, muxRegOffset, 0x44e10800, mode);
            } catch(ex2) {
                console.log('getPinMode(' + pin.key + '): ' + ex2);
            }
        }
        return(mode);
    }
};

f.pinMode = function(pin, direction, mux, pullup, slew, callback) {
    if(direction == gINPUT_PULLUP) pullup = 'pullup';
    pullup = pullup || ((direction == gINPUT) ? 'pulldown' : 'disabled');
    slew = slew || 'fast';
    mux = mux || 7; // default to GPIO mode
    //console.log('pinmode(' + [pin.key, direction, mux, pullup, slew].join(',') + ')');
    
    if(!pin.mux) {
        console.log('Invalid pin object for pinMode: ' + pin);
        throw('Invalid pin object for pinMode: ' + pin);
    }

    var muxFile = '/sys/kernel/debug/omap_mux/' + pin.mux;
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    
    // Handle case where pin is allocated as a gpio-led
    if(pin.led) {
        if((direction != gOUTPUT) || (mux != 7)) {                    
            console.log('pinMode only supports GPIO output for LEDs: ' + pin);
            if(callback) callback(false);
            return(false);
        }
        gpioFile = '/sys/class/leds/beaglebone::' + pin.led + '/brightness';
    }

    // Figure out the desired value
    var pinData = 0;
    if(slew == 'slow') pinData |= 0x40;
    if(direction != gOUTPUT) pinData |= 0x20;
    switch(pullup) {
    case 'disabled':
        pinData |= 0x08;
        break;
    case 'pullup':
        pinData |= 0x10;
        break;
    default:
        break;
    }
    pinData |= (mux & 0x07);
    
    try {
        var fd = fs.openSync(muxFile, 'w');
        fs.writeSync(fd, pinData.toString(16), null);
    } catch(ex) {
        console.error('Unable to configure mux for pin ' + pin + ': ' + ex);
        gpio[n] = {};
        if(callback) callback(false);
        return(false);
    }

    // Enable GPIO, if not already done
    var n = pin.gpio;
    if(mux == 7) {
        if(!gpio[n] || !gpio[n].path) {
            gpio[n] = {'path': gpioFile};
    
            if(pin.led) {
                fs.writeFileSync(
                    "/sys/class/leds/beaglebone::" + pin.led + "/trigger",
                    "gpio");
            } else {    
                // Export the GPIO controls
                var exists = path.existsSync(gpioFile);
                if(exists) {
                    //console.log("gpio: " + n + " already exported.");
                    fs.writeFileSync("/sys/class/gpio/gpio" + n + "/direction",
                        direction, null);
                } else {
                    try {
                        fs.writeFileSync("/sys/class/gpio/export", "" + n, null);
                        fs.writeFileSync("/sys/class/gpio/gpio" + n + "/direction",
                            direction, null);
                    } catch(ex2) {
                        console.error('Unable to export gpio-' + n + ': ' + ex2);
                        var gpioUsers = fs.readFileSync('/sys/kernel/debug/gpio', 'utf-8');
                        gpioUsers = gpioUsers.split('\n');
                        for(var x in gpioUsers) {
                            var y = gpioUsers[x].match(/gpio-(\d+)\s+\((\S+)\s*\)/);
                            if(y && y[1] == n) {
                                console.error('gpio-' + n + ' consumed by ' + y[2]);
                            }
                        }
                        gpio[n] = {};
                        if(callback) callback(false);
                        return(false);
                    }
                }
            }
        }
    } else {
        gpio[n] = {};
    }
    
    if(callback) callback(true);
    return(true);
};

f.digitalWrite = function(pin, value, callback) {
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    if(pin.led) {
        gpioFile = '/sys/class/leds/beaglebone::' + pin.led + '/brightness';
    }
    if(callback) {
        fs.writeFile(gpioFile, '' + value, null, callback);
    } else {
        fs.writeFileSync(gpioFile, '' + value, null);
    }
    return(true);
};

f.digitalRead = function(pin, callback) {
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    if(callback) {
        var readFile = function(err, data) {
            if(err) console.log('digitalRead error: ' + err);
            var value = parseInt(data, 2);
            callback({'value':value});
        };
        fs.readFile(gpioFile, readFile);
        return(true);
    }
    var value = parseInt(fs.readFileSync(gpioFile), 2);
    return(value);
};

f.analogRead = function(pin, callback) {
    var ainFile = '/sys/bus/platform/devices/tsc/ain' + (pin.ain+1);
    if(callback) {
        var readFile = function(err, data) {
            if(err) console.log('analogRead error: ' + err);
            var value = parseInt(data, 10) / pin.scale;
            callback({'value': value});
        };
        fs.readFile(ainFile, readFile);
        return(true);
    }
    var data = parseInt(fs.readFileSync(ainFile), 10);
    if(isNaN(data)) {
        throw('analogRead(' + pin.key + ') returned ' + data);
    }
    data = data / pin.scale;
    if(isNaN(data)) {
        throw('analogRead(' + pin.key + ') scaled to ' + data);
    }
    return(data);
}; 

f.shiftOut = function(dataPin, clockPin, bitOrder, val, callback) {
  var i;
  var bit;
  for (i = 0; i < 8; i++)  
  {
    if (bitOrder == gLSBFIRST) 
    {
         bit = val & (1 << i);
    } else
    {
         bit = val & (1 << (7 - i));
    }

    f.digitalWrite(dataPin, bit);
    f.digitalWrite(clockPin, gHIGH);
    f.digitalWrite(clockPin, gLOW);
    if(callback) callback();
  }
};

f.attachInterrupt = function(pin, handler, mode, callback) {
    if(!gpio[pin.gpio]) {
        if(callback) callback({'pin':pin, 'attached':false, 'configured':false});
        return(false);
    }
    if(gpio[pin.gpio].intProc) {
        if(callback) callback({'pin':pin, 'attached':false, 'configured':true});
        return(false);
    }
    console.log('Adding handler ' + handler + ' to pin ' + pin.key);
    var gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value';
    fs.writeFileSync('/sys/class/gpio/gpio' + pin.gpio + '/edge', mode);
    handler = (typeof handler === "string") ? myeval('(' + handler + ')') : handler;
    var intHandler = function(m) {
        var output = handler({'pin':pin, 'value':m.value});
        if(output && callback) callback({'pin':pin, 'output':output});
    };
    var intProc;
    if(child_process.fork) {
        intProc = child_process.fork(__dirname + '/gpioint.js');
    } else {
        var fork = require('fork');
        intProc = fork.fork(__dirname + '/gpioint.js');
    }
    intProc.on('message', intHandler);
    intProc.on('exit', function(code, signal) {
        if(callback) callback({
            'pin':pin,
            'code':code,
            'signal':signal,
            'died':true
        });
    });
    intProc.send({'pin':pin, 'mode':mode, 'file':gpioFile});
    gpio[pin.gpio].intProc = intProc;
    process.on('SIGTERM', function() {
        intProc.kill();
        if(callback) callback({'pin':pin, 'died':true});
    });
    if(callback) callback({'pin':pin, 'attached':true});
    return(true);
};

f.detachInterrupt = function(pin, callback) {
    if(!gpio[pin.gpio] || !gpio[pin.gpio].intProc) {
        if(callback) callback({'pin':pin, 'detached':false});
        return(false);
    }
    gpio[pin.gpio].intProc.kill();
    delete gpio[pin.gpio].intProc;
    if(callback) callback({'pin':pin, 'detached':true});
};

// See http://processors.wiki.ti.com/index.php/AM335x_PWM_Driver's_Guide
f.analogWrite = function(pin, value, freq, callback) {
    freq = freq || 1000;
    var path = '/sys/class/pwm/' + pin.pwm.path;
    //var curMode = getPinMode(pin);
    // Not yet possible to implement this test
    //if(curMode.direction != OUTPUT) {
    //    throw(pin.key + ' must be configured as OUTPUT for analogWrite()');
    //}
    if(!pin.pwm) {
        throw(pin.key + ' does not support analogWrite()');
    }
    if(pwm[pin.pwm.path] && pwm[pin.pwm.path].key) {
        if(pwm[pin.pwm.path].key != pin.key) {
            throw(pin.key + ' requires pwm ' + pin.pwm.name +
                ' but it is already in use by ' +
                pwm[pin.pwm].key
            );
         }
    } else {
        pwm[pin.pwm.path] = {};
        pwm[pin.pwm.path].key = '' + pin.key;
        pwm[pin.pwm.path].freq = freq;
        f.pinMode(pin, gOUTPUT, pin.pwm.muxmode, 'disabled', 'fast');

        // Clear up any unmanaged usage
        fs.writeFileSync(path+'/request', '0');

        // Allocate and configure the PWM
        fs.writeFileSync(path+'/request', '1');
        fs.writeFileSync(path+'/period_freq', freq);
        fs.writeFileSync(path+'/polarity', '0');
        fs.writeFileSync(path+'/run', '1');
    }
    if(pwm[pin.pwm.path].freq != freq) {
        fs.writeFileSync(path+'/run', '0');
        fs.writeFileSync(path+'/duty_percent', '0');
        fs.writeFileSync(path+'/period_freq', freq);
        fs.writeFileSync(path+'/run', '1');
        pwm[pin.pwm.path].freq = freq;
    }
    fs.writeFileSync(path+'/duty_percent', Math.round(value*100));
    if(callback) callback();
};

f.getEeproms = function(callback) {
    var EepromFiles = {
        '/sys/bus/i2c/drivers/at24/1-0050/eeprom': { type: 'bone' },
        '/sys/bus/i2c/drivers/at24/3-0054/eeprom': { type: 'cape' },
        '/sys/bus/i2c/drivers/at24/3-0055/eeprom': { type: 'cape' },
        '/sys/bus/i2c/drivers/at24/3-0056/eeprom': { type: 'cape' },
        '/sys/bus/i2c/drivers/at24/3-0057/eeprom': { type: 'cape' }
    };
    var eeproms = eeprom.readEeproms(EepromFiles);
    if(eeproms == {}) {
        console.warn('No valid EEPROM contents found');
    }
    if(callback) {
        callback(eeproms);
    }
    return(eeproms);
};

var myWorkers = [];
f.addLoop = function(loopFunc, loopDelay, callback) {
    loopFunc = (typeof loopFunc == "string") ? loopFunc : loopFunc.toString();
    console.log('Adding loop ' + loopFunc);
    loopDelay = loopDelay || 0;
    callback = callback || function(){};
    var worker = cluster.fork();
    var worker_kill = function() {
        worker.kill();
    };
    process.on('SIGTERM', worker_kill);
    var message_handler = function(m) {
        console.log('Parent got message ' + JSON.stringify(m));
        if(m.resolve) {
            var pairs = [];
            for(var name in m.resolve) {
                console.log('m.resolve[' + name + '] = ' + m.resolve[name]);
                var value = eval(m.resolve[name]);
                pairs.push({
                    'name': m.resolve[name],
                    'value': value
                });
            }
            worker.send({'vars': pairs});
        } else if(m.callback) {
            callback({'callback':m.value});
        }
    };
    worker.on('message', message_handler);
    myWorkers.push({
        'worker': worker,
        'loopFunc': loopFunc,
        'loopDelay': loopDelay
    });
    if(callback) {
        callback({'loopid':worker.pid});
    }
    return(worker.pid);
};

f.getLoops = function(callback) {
    var loops = {};
    for(var worker in myWorkers) {
        var id = myWorkers[worker].worker.pid;
        loops[id] = {};
        loops[id].loopFunc = myWorkers[worker].loopFunc;
        loops[id].loopDelay = myWorkers[worker].loopDelay;
    }
    if(callback) {
        callback({'loops':loops});
    }
    return(loops);
};

f.removeLoop = function(loopId, callback) {
    for(var worker in myWorkers) {
        if(myWorkers[worker].worker.pid == loopId) {
            process.kill(loopId);
            myWorkers.splice(worker, 1);
            if(callback) {
                callback({'loopId':loopId, 'removed':true});
            }
            return(true);
        }
    }
    if(callback) {
        callback({'loopId':loopId, 'removed':false});
    }
    return(false);
};

f.removeLoops = function(callback) {
    f.getLoops(function(x) {
        for(var loop in x.loops) {
            f.removeLoop(loop, callback);
        }
    });
};

f.doEval = function(evalFunc, callback) {
    evalFunc = (typeof evalFunc === "string") ? myeval('(' + evalFunc + ')') : evalFunc;
    var value = evalFunc(callback);
    if(callback) callback({'value':value});
    return(value);
};

f.readTextFile = function(filename, callback) {
    var cb = function(err, data) {
        callback({'err':err, 'data':data});
    };
    fs.readFile(filename, 'ascii', cb);
};

f.writeTextFile = function(filename, data, callback) {
    var cb = function(err) {
        callback({'err':err});
    };
    fs.writeFile(filename, data, 'ascii', cb);
};

// Wait for some time
if(misc.exists) {
    f.delay = function(milliseconds, callback) {
        misc.delay(milliseconds);
        if(callback) callback();
    };
} else {
    f.delay = function(milliseconds, callback) {
        var startTime = new Date().getTime();
        while(new Date().getTime() < startTime + milliseconds) {
        }
        if(callback) callback();
    };
}

// This is where everything is meant to happen
var needsToRun = true;
f.run = function(run_setup, run_loop) {
    if(!needsToRun) return(false);
    needsToRun = false;
    run_setup =
        ((typeof run_setup === "function") ? run_setup : false) ||
        ((typeof setup === "function") ? setup : false) ||
        (function(){});
    run_loop =
        ((typeof run_loop === "function") ? [ run_loop ] : false) ||
        ((typeof run_loop === "object") ? run_loop : false) ||
        ((typeof loop === "function") ? [ loop ] : false) ||
        ((typeof loop === "object") ? loop : false) ||
        [];
    if(cluster.isMaster) {
        //console.log('Evaluating ' + run_setup);
        //eval('(' + run_setup + ')();');
        run_setup();
        for(var x in run_loop) f.addLoop(run_loop[x], 0);
        cluster.on('death', function(worker) {
            console.log('Loop with PID ' + worker.pid + ' died');
        });
    } else {
        var childResolve = function childResolve(varNames) {
            var message = {'resolve': varNames};
            //console.log('Child sending message ' + JSON.stringify(message));
            process.send(message);
            var myListener = function(m) {
                //console.log('Child got message ' + JSON.stringify(m));
                if(m.vars) {
                    for(var pair in m.vars) {
                        try {
                            //console.log(m.vars[pair].name + ' = ' + m.vars[pair].value);
                            myeval(m.vars[pair].name + ' = ' + m.vars[pair].value);
                        } catch(ex) {
                            console.error('Unable to eval loop in ' + JSON.stringify(m));
                        }
                    }
                    var repeat = function repeat() {
                        var value = loopFunc();
                        if(value) process.send({'callback':true, 'value':value});
                        if(loopDelay) setTimeout(repeat, loopDelay);
                        else process.nextTick(repeat);
                    };
                    try {
                        repeat();
                    } catch(ex2) {
                        var errName = ex2.toString().match(/^ReferenceError: (\w+)\b/);
                        if(errName && errName[1]) {
                            childResolve([errName[1]]);
                        } else {
                            throw(ex2);
                        }
                    }
                    process.removeListener('message', myListener);
                    var message_handler = function(m) {
                        if(m.readVars) {
                            console.log('Child got message ' + JSON.stringify(m));
                            var message = {
                                'readVars': true,
                                'loopFunc': loopFunc,
                                'loopDelay': loopDelay
                            };
                            process.send(message);
                        }
                    };
                    process.on('message', message_handler);
                }
            };
            process.on('message', myListener);
        };
        childResolve(['loopFunc', 'loopDelay']);
    }
    return(true);
};
process.nextTick(f.run);

// This is a helper function for web servers
var loadFile = function(uri, subdir, res, type) {
    var filename = path.join(subdir, uri);
    path.exists(
        filename,
        function(exists) {
            if(!exists) {
                res.writeHead(404, {"Content-Type": "text/plain"});
                res.write("Error 404: '" + uri + "' Not Found\n");
                res.end();
                return;
            }
            if(type == "binary") {
                fs.readFile(
                    filename,
                    "binary",
                    function(err, file) {
                        if(err) {
                            res.writeHead(500, {"Content-Type": "text/plain"});
                            res.write(err + "\n");
                            res.end();
                            return;
                        }
                        res.writeHead(200);
                        res.write(file, "binary");
                        res.end();
                    }
                );
            } else {
                fs.readFile(
                    filename,
                    'utf8',
                    function(err, file) {
                        if(err) {
                            res.writeHead(500, {"Content-Type": "text/plain"});
                            res.write(err + "\n");
                            res.end();
                            return;
                        }
                        res.writeHead(200, {"Content-Type": type});
                        res.write("" + file);
                        res.end();
                    }
                );
            }
        }
    );
};

// most heavily borrowed from https://github.com/itchyny/browsershell
var spawn = function(socket) {
    var stream = '';
    var timer;
    var len = 0;
    var c;

    var send = function (data) {
       // add data to the stream
       stream += data.toString();
       ++len;

       // clear any existing timeout if it exists
       if(timer) clearTimeout(timer);

       // set new timeout
       timer = setTimeout(function () {
           socket.emit('shell', stream);
           stream = '';
           len = 0;
       }, 100);

       // send data if over threshold
       if(len > 1000)
       {
           clearTimeout(timer);
           socket.emit('shell', stream);
           stream = '';
           len = 0;
       }
    };

    var receive = function (msg) {
        if(!c) {
            try {
                console.log('Spawning bash');
                c = child_process.spawn('/bin/bash', ['-i'], {customFds: [-1, -1, -1]});
                c.stdout.on('data', send);
                c.stderr.on('data', send);
                c.on('exit', function() {
                    socket.emit('shell', send('\nexited\n'));
                    c = undefined;
                });
                socket.on('disconnect', function () {
                    console.log('Killing bash');
                    c.kill('SIGHUP');
                });
            } catch(ex) {
                c = undefined;
                send('Error invoking bash');
                console.log('Error invoking bash');
            }
        }
        if(c) {
            if(msg) {
                c.stdin.write(msg + '\n', 'utf-8');
            }
        } else {
            console.log('Unable to invoke child process');
        }
    };
    receive();

    return(receive);
};

var addSocketListeners = function() {};
if(socketio.exists) {
    addSocketListeners = function(server, onconnect) {
        var io = socketio.listen(server);
        io.set('log level', 2);
        console.log('Listening for new socket.io clients');
        io.sockets.on('connection', function(socket) {
            console.log('Client connected');

            // on disconnect
            socket.on('disconnect', function() {
                console.log('Client disconnected');
            });

            var shell = spawn(socket);
            var echo = function(data, callback) {
                console.log(data);
                callback({'data': data});
            };
            var platform = function(callback) {
                var msg = {'platform': platform};
                if(callback) callback(msg);
                return(msg);
            };

            var myfuncs = {
                'digitalWrite': { func: f.digitalWrite, args: [ 'pin', 'value' ] },
                'digitalRead': { func: f.digitalRead, args: [ 'pin' ] },
                'analogRead': { func: f.analogRead, args: [ 'pin' ] },
                'analogWrite': { func: f.analogWrite, args: [ 'pin', 'value', 'freq' ] },
                'pinMode': { func: f.pinMode, args: [ 'pin', 'direction', 'mux', 'pullup', 'slew' ] },
                'shiftOut': { func: f.shiftOut, args: [ 'dataPin', 'clockPin', 'bitOrder', 'val' ] },
                'attachInterrupt': { func: f.attachInterrupt, args: [ 'pin', 'handler', 'mode' ] },
                'detachInterrupt': { func: f.detachInterrupt, args: [ 'pin' ] },
                'getPinMode': { func: f.getPinMode, args: [ 'pin' ] },
                'getEeproms': { func: f.getEeproms, args: [] },
                'delay': { func: f.delay, args: [] },
                'platform': { func: platform, args: [] },
                'shell': { func: shell, args: [ 'command' ] },
                'echo': { func: echo, args: [ 'data' ] },
                'doEval': { func: f.doEval, args: [ 'evalFunc' ] },
                'addLoop': { func: f.addLoop, args: [ 'loopFunc', 'loopDelay' ] },
                'getLoops': { func: f.getLoops, args: [] },
                'removeLoop': { func: f.removeLoop, args: [ 'loopid' ] },
                'removeLoops': { func: f.removeLoops, args: [] },
                'readTextFile': { func: f.readTextFile, args: [ 'filename' ] },
                'writeTextFile': { func: f.writeTextFile, args: [ 'filename', 'data' ] }
            };
            var callMyFunc = function(name, m) {
                var callback = function(resp) {
                    resp = resp || {};
                    if(m && m.seq) resp.seq = m.seq;
                    // TODO: consider setting 'oneshot'
                    socket.emit(name, resp);
                };
                try {
                    var callargs = [];
                    for(var arg in myfuncs[name].args) {
                        var argname = myfuncs[name].args[arg];
                        if(m) {
                            callargs.push(m[argname]);
                        } else {
                            callargs.push(undefined);
                        }
                    }
                    callargs.push(callback);
                    myfuncs[name].func.apply(this, callargs);
                } catch(ex) {
                    console.log('Error handing ' + name + ' message: ' + ex);
                }
            };
            var addSocketX = function(name) {
                socket.on(name, function(m) { callMyFunc(name, m); });
            };
            for(var myfunc in myfuncs) {
                addSocketX(myfunc);
            }

            // call user-provided on-connect function
            if(typeof onconnect == 'function')
                onconnect(socket);
        });
    };
}

exports.Server = function(port, subdir, onconnect) {
    port = port || (process.env.LISTEN_PID > 0 ? 'systemd' : 80);
    subdir = path.join(process.cwd(), subdir);
    var handler = function(req, res) {
        var uri = url.parse(req.url).pathname;
        if(uri == '/') {
            loadFile('index.html', subdir, res, "text/html");
        } else {
            if(uri.match(/\.js$/i)) {
                loadFile(uri, subdir, res, "application/javascript");
            } else if(uri.match(/\.css$/i)) {
                loadFile(uri, subdir, res, "text/css");
            } else if(uri.match(/\.htm(.)$/i)) {
                loadFile(uri, subdir, res, "text/html");
            } else if(uri.match(/\.svg$/i)) {
                loadFile(uri, subdir, res, "image/svg+xml");
            } else if(uri.match(/\.(jpg|png|gif|ico)$/i)) {
                loadFile(uri, subdir, res, "binary");
            } else {
                loadFile(uri, subdir, res, "text/plain");
            }
        }
    };
    this.server6 = http.createServer();
    this.server6.addListener('request', handler);
    addSocketListeners(this.server6, onconnect);
    this.server = http.createServer();
    this.server.addListener('request', handler);
    addSocketListeners(this.server, onconnect);
    this.begin = function() {
        this.server6.listen(port, '::0');
        this.server.listen(port);
    };
};

// Exported variables
exports.OUTPUT = gOUTPUT;
exports.INPUT = gINPUT;
exports.INPUT_PULLUP = gINPUT_PULLUP;
exports.HIGH = gHIGH;
exports.LOW = gLOW;
exports.LSBFIRST = gLSBFIRST;
exports.MSBFIRST = gMSBFIRST;
exports.CHANGE = gCHANGE;
exports.RISING = gRISING;
exports.FALLING = gFALLING;
exports.bone = platform; // this likely needs to stay platform and be detected
for(var x in f) {
    exports[x] = f[x];
}

// Global variable assignments
// This section is broken out because it will eventually be deprecated
OUTPUT = exports.OUTPUT;
INPUT = exports.INPUT;
INPUT_PULLUP = exports.INPUT_PULLUP;
HIGH = exports.HIGH;
LOW = exports.LOW;
LSBFIRST = exports.LSBFIRST;
MSBFIRST = exports.MSBFIRST;
CHANGE = exports.CHANGE;
RISING = exports.RISING;
FALLING = exports.FALLING;
bone = exports.bone; // this likely needs to be platform and detected
getPinMode = exports.getPinMode;
pinMode = exports.pinMode;
digitalWrite = exports.digitalWrite;
digitalRead = exports.digitalRead;
analogRead = exports.analogRead;
analogWrite = exports.analogWrite;
shiftOut = exports.shiftOut;
attachInterrupt = exports.attachInterrupt;
detachInterrupt = exports.detachInterrupt;
getEeproms = exports.getEeproms;
delay = exports.delay;
doEval = exports.doEval;
addLoop = exports.addLoop;
getLoops = exports.getLoops;
removeLoop = exports.removeLoop;
removeLoops = exports.removeLoops;
readTextFile = exports.readTextFile;
writeTextFile = exports.writeTextFile;
